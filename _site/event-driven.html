<!DOCTYPE html><html lang="en-US"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=Edge"><link rel="shortcut icon" href="http://localhost:4000/githubPage/favicon.ico" type="image/x-icon"><link rel="stylesheet" href="http://localhost:4000/githubPage/assets/css/just-the-docs-default.css"> <script type="text/javascript" src="http://localhost:4000/githubPage/assets/js/vendor/lunr.min.js"></script> <script type="text/javascript" src="http://localhost:4000/githubPage/assets/js/just-the-docs.js"></script><meta name="viewport" content="width=device-width, initial-scale=1"><title>Event Driven | Future of Application Development</title><meta name="generator" content="Jekyll v4.2.1" /><meta property="og:title" content="Event Driven" /><meta property="og:locale" content="en_US" /><meta name="description" content="IBM PoV of future cloud application development" /><meta property="og:description" content="IBM PoV of future cloud application development" /><link rel="canonical" href="http://localhost:4000/githubPage/event-driven" /><meta property="og:url" content="http://localhost:4000/githubPage/event-driven" /><meta property="og:site_name" content="Future of Application Development" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Event Driven" /> <script type="application/ld+json"> {"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"http://localhost:4000/githubPage/images/logo.png"}},"@type":"WebPage","url":"http://localhost:4000/githubPage/event-driven","headline":"Event Driven","description":"IBM PoV of future cloud application development","@context":"https://schema.org"}</script><body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"><title>Link</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"><title>Search</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"><title>Menu</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"><title>Expand</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"><polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"><title>Document</title><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg><div class="side-bar"><div class="site-header"> <a href="http://localhost:4000/githubPage/" class="site-title lh-tight"><div class="site-logo"></div></a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a></div><nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"><ul class="nav-list"><li class="nav-list-item"><a href="http://localhost:4000/githubPage/" class="nav-list-link">Home</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/key-drivers" class="nav-list-link">Key Drivers</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/target-opt-model" class="nav-list-link">Target Operating Model</a><li class="nav-list-item active"><a href="http://localhost:4000/githubPage/arch" class="nav-list-link">Architecture</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/delivery" class="nav-list-link">Delivery Model</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/devsecops-principles" class="nav-list-link">DevSecOps Principles</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/sw-engineering" class="nav-list-link">Software Engineering Practices</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/lowcode-nocode" class="nav-list-link">Low-Code No-Code</a><li class="nav-list-item"><a href="http://localhost:4000/githubPage/contact" class="nav-list-link">Contact Us</a></ul></nav><footer class="site-footer"> This site uses <a href="https://github.com/pmarsceill/just-the-docs">Just the Docs</a>, a documentation theme for Jekyll.</footer></div><div class="main" id="top"><div id="main-header" class="main-header"><div class="search"><div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search Future of Application Development" aria-label="Search Future of Application Development" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label></div><div id="search-results" class="search-results"></div></div><nav aria-label="Auxiliary" class="aux-nav"><ul class="aux-nav-list"><li class="aux-nav-list-item"> <a href="https://w3.ibm.com/services/lighthouse/spaces/view/cloud-build-cad-csia/overview" class="site-button" target="_blank" rel="noopener noreferrer" > Build Spaces </a><li class="aux-nav-list-item"> <a href="https://w3.ibm.com/w3publisher/cas-move-build-offerings" class="site-button" target="_blank" rel="noopener noreferrer" > Build Offering Portal </a></ul></nav></div><div id="main-content-wrap" class="main-content-wrap"><nav aria-label="Breadcrumb" class="breadcrumb-nav"><ol class="breadcrumb-nav-list"><li class="breadcrumb-nav-list-item"><a href="http://localhost:4000/githubPage/arch">Architecture</a><li class="breadcrumb-nav-list-item"><span>Event Driven</span></ol></nav><div id="main-content" class="main-content" role="main"><h1 class="no_toc" id="event-driven-architecture"> <a href="#event-driven-architecture" aria-labelledby="event-driven-architecture" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Event Driven Architecture</h1><hr /> <details open=""> <summary class="text-delta"> Table of Contents </summary><ol id="markdown-toc"><li><a href="#introduction" id="markdown-toc-introduction">Introduction</a><li><a href="#eda-overview" id="markdown-toc-eda-overview">EDA Overview</a><li><a href="#eda-characteristics" id="markdown-toc-eda-characteristics">EDA Characteristics</a><li><a href="#typical-eda-use-cases" id="markdown-toc-typical-eda-use-cases">Typical EDA Use Cases</a><li><a href="#ibms-pov-on-eda" id="markdown-toc-ibms-pov-on-eda">IBM’s PoV on EDA</a><ol><li><a href="#architectural-blueprint-for-eda-microservices-systems" id="markdown-toc-architectural-blueprint-for-eda-microservices-systems">Architectural Blueprint for EDA-Microservices Systems</a><li><a href="#architectural-concerns--complexities" id="markdown-toc-architectural-concerns--complexities">Architectural Concerns &amp; Complexities</a><li><a href="#key-architectural-considerations" id="markdown-toc-key-architectural-considerations">Key Architectural Considerations</a><li><a href="#architectural-patterns" id="markdown-toc-architectural-patterns">Architectural Patterns</a><li><a href="#technology-stack" id="markdown-toc-technology-stack">Technology Stack</a><li><a href="#event-modeling" id="markdown-toc-event-modeling">Event Modeling</a><li><a href="#event-processing-topology" id="markdown-toc-event-processing-topology">Event Processing Topology</a><li><a href="#deployment-topology" id="markdown-toc-deployment-topology">Deployment Topology</a><li><a href="#exception-handling-strategy" id="markdown-toc-exception-handling-strategy">Exception Handling Strategy</a><li><a href="#event-backbone-capabilities-and-constraints" id="markdown-toc-event-backbone-capabilities-and-constraints">Event Backbone Capabilities and Constraints</a><li><a href="#security" id="markdown-toc-security">Security</a><li><a href="#observability" id="markdown-toc-observability">Observability</a><li><a href="#fault-tolerance-and-response" id="markdown-toc-fault-tolerance-and-response">Fault Tolerance and Response</a><li><a href="#references" id="markdown-toc-references">References</a></ol></ol></details><hr /><h2 id="introduction"> <a href="#introduction" aria-labelledby="introduction" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Introduction</h2><p>Today’s IT systems are generating, collecting, and processing more data than ever before. And, they are dealing with highly complex processes (that are being automated) and integrations between systems and devices that cut across typical organizational boundaries. At the same time, IT systems are expected to be developed more quickly and cheaply, while also being highly available, scalable, and resilient.</p><p>To achieve these aims, developers are adopting architectural styles and programming paradigms, such as micoservices, event-driven architecture, DevOps, and more. New tools and frameworks are being built to help developers deliver on these expectations.</p><p>Developers are combining Event Driven Architecture (EDA) and Microservices architectural styles to build systems that are extremely scalable, available, fault tolerant, concurrent, and easy to develop and maintain. By combining these two architectural styles, developers can build distributed, highly scalable, available, fault-tolerant, and extensible systems. These systems can consume, process, aggregate, or correlate extremely large amounts of events or information in real-time. Developers can easily extend and enhance these systems by using industry-standard open-source frameworks and cloud platforms.</p><hr /><h2 id="eda-overview"> <a href="#eda-overview" aria-labelledby="eda-overview" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> EDA Overview</h2><p><strong>Event Driven Architecture (EDA)</strong> has existed for a long time. Cloud, microservices, and serverless programming paradigms and sophisticated development frameworks are increasing the applicability of EDA in solving mission critical business problems in real time. Technologies and Platforms, such as <a href="https://kafka.apache.org/" target="_blank">Kafka</a>, <a href="https://developer.ibm.com/components/cloud-pak-for-integration/" target="_blank">IBM Cloud Pak for Integration</a>, and <a href="https://www.lightbend.com/">Lightbend</a>, and development frameworks such as <a href="https://spring.io/projects/spring-cloud-stream" target="_blank">Spring Cloud Stream</a>, <a href="https://quarkus.io/" target="_blank">Quarkus</a>, and <a href="https://camel.apache.org/" target="_blank">Camel</a>, all provide first class support to EDA development. EDA is also extended for ‘streaming data processing’ which is a requirement for developing real-time artificial intelligence or machine learning solutions.</p><hr /><h2 id="eda-characteristics"> <a href="#eda-characteristics" aria-labelledby="eda-characteristics" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> EDA Characteristics</h2><ul><li>Loose coupling between components/services<li>Ability to scale individual components<li>Processing components can be developed independent of each other<li>High cloud affinity<li>Asynchronous nature. As well as ability to throttle workload<li>Fault Tolerance and better resiliency<li>Ability to build processing pipelines<li>Availability of sophisticated event brokers reduce code complexity<li>A rich palate of proven <a href="https://www.enterpriseintegrationpatterns.com/" target="_blank">Enterprise Integration Patterns</a></ul><hr /><h2 id="typical-eda-use-cases"> <a href="#typical-eda-use-cases" aria-labelledby="typical-eda-use-cases" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Typical EDA Use Cases</h2><p>Typical EDA use cases span across all the use cases where real time processing is required. In addition, rapid digitization of business processes systems are generating events which might drive processes in other systems. i.e. systems need to communicate with each other. With the advent of new technologies, use cases that were traditionally developed as batch jobs can now be done in near real-time using <strong>stream data processing</strong>.</p><p>Following categories of use cases are best fit for EDA:</p><ol><li>IoT use cases - where there are IoT devices sending events which need to be correlated and processed<li>Real time stream data processing for computing aggregations, building data stores/in-memory data grids, etc. These data stores and computed aggregations can be used for near real-time MI reporting.<li>Systems integration for processing offline/asynchronous business processes<li>Real time data analytics<li>Monitoring and Alerting (not just systems monitoring, but monitoring of critical business processes - e.g. fraud detection, risk, etc.)</ol><p>EDA is extremely powerful when combined with Microservices and Cloud.</p><hr /><h2 id="ibms-pov-on-eda"> <a href="#ibms-pov-on-eda" aria-labelledby="ibms-pov-on-eda" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> IBM’s PoV on EDA</h2><p><br /></p><h3 id="architectural-blueprint-for-eda-microservices-systems"> <a href="#architectural-blueprint-for-eda-microservices-systems" aria-labelledby="architectural-blueprint-for-eda-microservices-systems" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Architectural Blueprint for EDA-Microservices Systems</h3><p>The following figure is an architectural diagram of an EDA-Microservices-based enterprise system. Some microservices components and types are shown separately for better clarity of the architecture.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><strong>Event Driven MicroServices Architecture Overview</strong><tbody><tr><td style="text-align: center"><img src="images/eda-arch-ovw.png" alt="Event Driven MicroServices Architecture Overview" /></table></div><p>The EDA and Microservices specific components in this blueprint are:</p><ul><li><p><strong><a href="https://www.ibm.com/cloud/architecture/architecture/practices/event-driven-event-backbone-architecture">Event backbone</a></strong>. The event backbone is primarily responsible for transmission, routing, and serialization of events. It can provide APIs for processing event streams. The event backbone offers support for multiple serialization formats and has a major influence on architectural qualities such as fault tolerance, elastic scalability, throughput, and so on. Events can also be stored to create <em>event stores</em>. An <a href="https://martinfowler.com/eaaDev/EventSourcing.html" target="_blank">event store</a> is a key architectural pattern for recovery and resiliency.</p><li><p><strong>Services Layer</strong>. The services layer consists of microservices, integration, and data and analytics services. These services expose their functionality through a variety of interfaces, including REST API, UI, or as EDA event producers and consumers. The services layer also contains services that are specific to EDA and that address cross-cutting concerns, such as orchestration services, streaming data processing services, and so on.</p><li><p><strong>Data Layer</strong>. The data layer typically consists of two sublayers. In this blueprint, individual databases owned by microservices are not shown.</p><ul><li><em>Caching layer</em>, which provides distributed and in-memory data caches or grids to improve performance and support patterns such as CQRS. It is horizontally scalable and may also have some level of replication and persistence for resiliency.<li><em>Big data layer</em>, which is comprised of data warehouses, ODS, data marts, and AI/ML model processing.</ul><li><p><strong>Microservices Chassis</strong>. The microservices chassis provides the necessary technical and cross-cutting services that are required by different layers of the system. It provides development and runtime capabilities. By using a microservices chassis, you can reduce design and development complexity and operating costs, while you improve time to market, quality of deliverables, and manageability of a huge number of microservices.</p><li><p><strong>Deployment Platform</strong>: Elastic, cost optimized, secure, and easy to use cloud platforms should be used. Developers should use as many PaaS services as possible to reduce maintenance and management overheads. The architecture should also provision for hybrid cloud setup, so platforms such as <a href="https://www.openshift.com/" target="_blank">Red Hat OpenShift</a> should be considered.</p></ul><p><br /></p><h3 id="architectural-concerns--complexities"> <a href="#architectural-concerns--complexities" aria-labelledby="architectural-concerns--complexities" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Architectural Concerns &amp; Complexities</h3><p>EDA also introduces some major architectural concerns. Some of these concerns include:</p><ul><li><p>A large number of distributed and independently deployed components or services, which introduces these issues:</p><ul><li>Design and implementation complexity. Understanding and debugging of such systems is difficult. Event processing workflows are not intuitive and need to be documented.<li>Multiple points of failure. Increased complexity in testing, debugging, and exception handling.<li>The release process, deployment, and system monitoring gets complicated and requires high level of automation.<li>From a development perspective, consistency in implementation, conformance to design, and implementation standards is desired. However, there are multiple development squads. This could result in inconsistent implementation and quality issues. Therefore, the development of a reference architecture that outlines the use of architectural patterns, development frameworks, development of reusable services or utilities, and setting up a robust and effective governance model is essential.</ul><li><p>Asynchronous event processing is difficult compared to synchronous processing due to requirements related to event ordering or sequencing, callbacks, and exception handling.</p><li><p>Losing information or events is not desirable (obviously). So, the requirements for extremely highly available, scalable, and fault-tolerant systems are especially important, which makes designing and deployment of the systems quite complex. Event producers and consumers have to be designed to withstand failures, have the ability to replay failed events, and have deduplication capabilities.</p><li><p>Lack of support for distributed transactions. This issue means that developers must create custom and complex rollback and recovery implementations spanning across multiple distributed systems.</p><li><p>Maintaining data consistency. Due to the distributed nature and multiple systems of record, maintaining data consistency is complex. In most of the cases, it is eventual consistency due to lack of atomic transactions across multiple distributed systems.</p><li><p>Event consumers and producers have to consider properties that are specific to products that are used for event brokers, data caches, and so on. For example, delivery guarantee influences the design of producers and consumers.</p></ul><p><br /></p><h3 id="key-architectural-considerations"> <a href="#key-architectural-considerations" aria-labelledby="key-architectural-considerations" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Key Architectural Considerations</h3><p>Architectural considerations influence the architecture of a system. They act as guide rails to make architectural decisions. They have a major influence on non-functional characteristics of the system. The following architectural considerations are extremely important for event-driven, microservices-based systems:</p><ul><li>Architectural patterns<li>Technology stack<li>Event modeling<li>Processing topology<li>Deployment topology<li>Exception handling<li>Leveraging event backbone capabilities<li>Security<li>Observability<li>Fault tolerance and response</ul><p><br /></p><h3 id="architectural-patterns"> <a href="#architectural-patterns" aria-labelledby="architectural-patterns" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Architectural Patterns</h3><p>Choosing architectural and integration patterns is a critical architectural consideration for event-driven, microservices-based systems. They provide proven and tested solutions for many desired architectural qualities. The following architectural patterns are extremely useful in developing event-driven, microservices-based systems:</p><ul><li><a href="https://www.enterpriseintegrationpatterns.com/patterns/messaging/PipesAndFilters.html" target="_blank">Pipes &amp; Filters</a><li><a href="https://github.com/mdwelsh/mdwelsh.github.io/blob/master/papers/seda-sosp01.pdf" target="_blank">Staged Event Driven Architecture (SEDA)</a><li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/patterns/event-sourcing/" target="_blank">Event Sourcing</a><li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/patterns/cqrs/" target="_blank">Command Query Responsibility Segregation (CQRS)</a><li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/patterns/saga/" target="_blank">SAGA</a><li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/patterns/realtime-analytics/" target="_blank">Stream Processing</a><li><a href="https://microservices.io/patterns/microservice-chassis.html" target="_blank">Microservices Chassis</a><li><a href="https://ibm-cloud-architecture.github.io/refarch-eda/patterns/dlq/" target="_blank">Dead Letter Queues (DLQ)</a></ul><p>Additionally, many <a href="https://www.enterpriseintegrationpatterns.com/" target="_blank">Enterprise Integration Patterns</a> and <a href="https://microservices.io/patterns/" target="_blank">Microservices patterns</a> provide the building blocks for event-driven microservices-based systems.</p><p>Patterns need to be chosen based on requirements and architectural qualities that are desired from the system.</p><p><br /></p><h3 id="technology-stack"> <a href="#technology-stack" aria-labelledby="technology-stack" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Technology Stack</h3><p>The components such as event brokers, data caches or grids, microservices frameworks, security mechanisms, distributed databases, monitoring systems, and alerting systems form the technology backbone of event-driven, microservices-based systems. This backbone provides support for key architectural qualities (performance, availability, reliability, operating cost, fault-tolerance, and so on) and simplifies development. It also influences several design and development decisions.</p><p>When choosing your technology stack, consider these characteristics:</p><ul><li><strong>Horizontal Scalability</strong> of individual components. Scaling should not compromise availability. That is, the addition of nodes should not require downtime.<li><strong>High Availability</strong> of individual components. The selected product or framework should support clustering with capability to have members across different availability zones or regions, support rolling upgrades, support data replication, and should be fault-tolerant which means the cluster should re-balance itself in case of loss of nodes.<li><strong>Cloud Affinity</strong>, which means it should be easy to deploy on cloud. In fact, if they are available as services on a PaaS platform, its even better because it reduces management and maintenance overhead. Support for containerization is a must.<li><strong>Low operating cost</strong>, which means it should be able to run on commodity hardware and should be frugal in terms of CPU, memory, and storage.<li><strong>Configurability</strong> and tuning of the behavior and non-functional characteristics without downtime.<li><strong>Manageability</strong>.<li><strong>Vendor lock-in</strong> should be avoided. Choose products that are based on open standards or are open source products. When choosing an open source product, consider how widely adopted the product is, whether it has a thriving developer community, and the license should be open and not very restrictive (such as the Apache License V2.0).<li>For event brokers and development frameworks, they should have support for:<ul><li>Multiple serialization formats (JSON, AVRO, Protobuf, etc.)<li>Exception handling and dead letter queues (DLQs)<li>Stream processing (including support for aggregations, joins, and windowing)<li>Partitioning and preserving the order of events</ul><li><strong>Reactive programming</strong> support is nice to have.<li><strong>Polyglot programming</strong> support is nice to have in Event backbone.</ul><p>Following table lists down the popular choices for different components:</p><div class="table-wrapper"><table><thead><tr><th>Component Type<th>Choices<tbody><tr><td>Event Backbone<td><a href="https://kafka.apache.org/" target="_blank">Apache Kafka</a>, integration platforms such as <a href="https://developer.ibm.com/components/cloud-pak-for-integration/" target="_blank">IBM Cloud Pak for Integration</a>, <a href="https://www.lightbend.com/" target="_blank">Lightbend</a>, AWS Eventbridge + Kinesis<tr><td>Microservices development frameworks<td>Spring frameworks such as <a href="https://spring.io/projects/spring-boot" target="_blank">Spring Boot</a>, <a href="https://spring.io/projects/spring-cloud-stream" target="_blank">Spring Cloud Stream</a>, <a href="https://quarkus.io/" target="_blank">Quarkus</a>, <a href="https://camel.apache.org/" target="_blank">Apache Camel</a><tr><td>Data Caches/Grids<td><a href="https://ignite.apache.org/" target="_blank">Apache Ignite</a>, <a href="https://redislabs.com/redis-enterprise/use-cases/caching/" target="_blank">Redis</a>, <a href="https://www.ehcache.org/" target="_blank">Ehcache</a>, <a href="https://www.elastic.co/elasticsearch/" target="_blank">Elasticsearch</a>, <a href="https://hazelcast.org/" target="_blank">Hazelcast</a><tr><td>Observability<td><a href="https://prometheus.io/" target="_blank">Prometheus</a> + <a href="https://grafana.com/" target="_blank">Grafana</a>, <a href="https://www.elastic.co/what-is/elk-stack" target="_blank">ELK</a>, <a href="https://github.com/statsd/statsd" target="_blank">StatsD</a> + <a href="https://graphiteapp.org/" target="_blank">Graphite</a> , Sysdig, AppDynamics, Datadog</table></div><p><br /></p><h3 id="event-modeling"> <a href="#event-modeling" aria-labelledby="event-modeling" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Event Modeling</h3><p>Event modeling consists of defining event types, event hierarchy, event metadata, and payload schemas. Carefully consider these event modeling characteristics:</p><ul><li><p><strong>Event types</strong>. In an enterprise system there are multiple business domains each consuming and producing different types of events. One of the key aspects of modeling is identifying events types and events. Use domain driven design and practices such as <a href="https://www.ibm.com/cloud/architecture/architecture/practices/event-storming-methodology-architecture" target="_blank">event storming</a> and <a href="https://www.ibm.com/cloud/architecture/architecture/practices/event-driven-sources-architecture" target="_blank">event sources</a>, to identify and classify events. Event types can be hierarchical in nature which help in having a layered approach to event processing. Define event types and events to cover all business requirements and map them to different business processes or workflows. Granularity of event types is of key importance to avoid tight coupling between components. Event types are key to defining routing rules.</p><li><p><strong>Event schema</strong>. Event schema is comprised of event metadata (such as type, time, source system, and so on) and payload (that is, information) that is used for processing by event processors. Event type is typically used for routing. Event metadata is typically used for correlating and ordering events, but it can be used for audit and authorization purposes as well. Payloads influence the sizing of queues, topics and event stores, network performance, (de)serialization performance, and resource utilization. Avoid duplicating content. You can always just regenerate the state by replaying the events whenever required.</p><li><p><strong>Versioning</strong>. Requirements and implementation evolve over time and they often will impact the event model. Changes to the event model can potentially impact too many microservices. Changing all impacted services simultaneously is not practical. Therefore, the event model should have support for multiple versions and be backward compatible so that microservices can change at a time convenient to them. It is also a good idea to add new attributes to the payload instead of changing the existing attributes (deprecate instead of change). Versioning is dependent on serialization format.</p><li><p><strong>Serialization format</strong>. There are multiple serialization formats that can be used to encode the event and its payload, such as <a href="https://en.wikipedia.org/wiki/JSON" target="_blank">JSON</a>, <a href="https://en.wikipedia.org/wiki/Protocol_Buffers" target="_blank">protobuf</a>, or <a href="https://en.wikipedia.org/wiki/Apache_Avro" target="_blank">Apache Avro</a>. Important considerations here are schema evolution support, (de)serialization performance and serialized size. It is very easy to develop and debug JSON because the event message is human readable, but JSON is not performant and could increase the event storage requirement. Whereas Avro or Protobuf reduce the size of the payload, are fast, and support schema evolution, they require additional design and development effort.</p><li><p><strong>Partitioning</strong>. The partitioning of events is important to increase concurrency, scalability, and availability. Partitioning is also key to the ordering of messages. From an architecture perspective, selecting a partitioning key is important. Having a very coarse-grained key will impact scalability and concurrency. Having a very fine-grained key might not help in preserving order of events. In event brokers such as Kafka, partitioning bounds the scalability of event consumers.</p><li><p><strong>Ordering</strong>. Some events might need to be ordered (at least for the given entity) based on their arrival time. For example, account transactions for a given account have to be processed sequentially. It is important to identify events that require ordering. Ordering should be used only where it is essential, since it has an impact on performance and throughput. In Apache Kafka, ordering of events is directly related to partitioning.</p><li><p><strong>Event durability</strong> Durability means how long should the event be available on the queues or topics. For example, should you delete the event as soon as it is consumed. Delete events older than the configured retention period. Delete events which have explicit markers (such as tombstones in Kafka). Based on the requirements, one of these should be chosen and configured. While using timebased retention, consider how long the events should be available for replay if required. If the event store pattern is being used, then an additional question about number of versions of the same event or payload that need to be maintained has to be thought about. Event brokers such as Kafka provide various configuration options that can be set at the topic level to specify the durability of events.</p></ul><p><br /></p><h3 id="event-processing-topology"> <a href="#event-processing-topology" aria-labelledby="event-processing-topology" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Event Processing Topology</h3><p>In EDA, processing topology refers to the organization of producers, consumers, enterprise integration patterns, and topics and queues to provide event processing capability. They are basically event processing pipelines where parts of functional logic (processors) are joined together using enterprise integration patterns and queues and topics. Processing topology is a combination of the SEDA, EIP, and Pipes &amp; Filter patterns. For complex event processing, multiple processing topologies can be connected to each other.</p><p>Another key concept in processing topology is <strong>orchestration vs. choreography</strong>. <em>Orchestration</em> refers to having a central orchestrator that orchestrates the processing workflow by calling different components. Whenever a strict control is required over processing, orchestration is chosen, such as for payments processing. Orchestration is typically used where the SAGA pattern is employed. Orchestration has a trade-off with performance and availability (as the orchestrator could become the single point of failure). <em>Choreography</em> refers to a completely de-centralized way of processing. That is, events are published and interested components subscribe to topics. There is no central component to control the processing flow. Choreography is complex to implement and maintain.</p><p>Consider these guidelines for creating processing topologies:</p><ul><li>Processing stages (processors) should be connected using persistent queues and topics.<li>Configure partitioning keys and message retention policies at each queue or topic.<li>Granularity of processing is important. If the processors are too fine grained, then there is a chance of tight coupling between processors. Ideally, each processor should be logically independent of each other.<li>Microservices can be used for implementing processors. This allows for loose coupling, segregation of responsibilities, and ease of development.<li>Processing concurrency should be configurable at processor level.<li>Use proven Enterprise Integration Patterns (EIPs). Choose development frameworks that provide built-in support for EIP such as Apache Camel or Spring-cloud-stream.<li>Build modular and hierarchical processing topologies such that complex event processing is achieved by assembling simple processing pipelines. This helps in making the implementation modular and easy to update.<li>If processors have a state (that changes with events), consider having stores to back the states for increased fault-tolerance and recoverability.</ul><p>Architectural practices such as <a href="https://www.ibm.com/cloud/architecture/architecture/practices/event-driven-sources-architecture" target="_blank">Process event streams</a> and <a href="https://www.ibm.com/cloud/architecture/architecture/practices/event-driven-event-managed-state-architecture" target="_blank">Event managed state</a> can be used to design the processing topology. It is also good to have a detailed understanding of event broker capabilities while defining the processing topology. For instance Kafka streams provides first class support for defining event stream processing topologies. Kakfa also provides automatic support for state stores when performing aggregation and join operations on event streams.</p><p>The following figure depicts a blueprint of a processing topology:</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><strong>Event Processing Pipeline</strong><tbody><tr><td style="text-align: center"><img src="images/eda-pipes.png" alt="event processing pipeline" /></table></div><p>And this following figure depicts a simplified order processing toplogy for online shopping. The router has the ability to dynamically route events to multiple topics. Also note that event processors will also have ‘event filters’ to control consumption and production of events based on context.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><strong>Order Processing Topology</strong><tbody><tr><td style="text-align: center"><img src="images/order-processing-topology.png" alt="order-processing-topology" /></table></div><p><br /></p><h3 id="deployment-topology"> <a href="#deployment-topology" aria-labelledby="deployment-topology" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Deployment Topology</h3><p>In an EDA-microservices architecture, there are numerous components to deploy. A deployment topology should be chosen such that architectural requirements related to scalability, availability, resiliency, security, and cost are met. However, there are tradeoffs to be made between redundancy, performance, and cost. Deployment to cloud makes the architecture even more performant, resilient, and cost efficient. Capabilities that are provided by cloud deployments (such as <code class="language-plaintext highlighter-rouge">high availability</code> setup in Kubernetes) should be exploited.</p><p>Consider these key principles to consider for your deployment topology:</p><ul><li><p>Each deployed component should be independently scalable and deployed as a cluster to increase concurrency and resiliency.</p><li><p>Ensure that each cluster spans across multiple availability zones. This setup gives more resiliency in case of data-center failures. An added advantage of this is, instead of having a passive DR, an active-active deployment across different availability zones or regions can be done.</p><li><p>Replication factor determines the number of replicas of an event or information. Without replication, failure of individual instances (even though clustered) would result in data loss. This is especially required for event brokers and databases. However, replication comes at compute and storage cost. Replication should be set based on factors such as availability zones, data regions, number of nodes, and so on.</p><li><p>In the case of Kafka, the number of topic partitions places an upper bound on concurrency of consumers.</p><li><p>Throttling of workloads. Configure thread pools and the number of instances of consumers and producers to throttle throughput. Depending on the volume and throughput of the downstream processors, these parameters need to be adjusted accordingly.</p><li><p>Data compression. If the payload size is big and CPU availability is high, then compression can be used to compress the events before transmission. However, compression is a tradeoff between network utilization and CPU utilization.</p><li><p>Data encryption. Based on security standards in the organization, configure TLS, authentication, and authorization between the event broker and producers and consumers (and for your databases). Please note that enabling TLS can increase CPU utilization.</p></ul><p>Additionally, it is important to have support for automated deployments, automated failover, rolling upgrades or blue-green deployments, and the externalization of the configuration to make the environment of the deployment artifacts independent.</p><h3 id="exception-handling-strategy"> <a href="#exception-handling-strategy" aria-labelledby="exception-handling-strategy" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Exception Handling Strategy</h3><p>In EDA, having a comprehensive and consistent exception handling strategy is important to improve resiliency. Exception handling strategy consists of all or some of the following:</p><ul><li>Logging the exception<li>Retrying the event for specified number of time and at specified retry intervals<li>Moving the event to a dead letter queue (or stopping the processing of events), if all retries are exhausted<li>Raising alerts<li>In some cases, generating an event<li>Correcting the cause of exception and replaying the event</ul><p>Exceptions can be of two types: business exceptions and system exceptions. Business exceptions are raised when validations or a business condition fails. System exceptions are a broad category of failures due to unavailability of components (database, event broker, or other microservices) or due to resource issues (such as <code class="language-plaintext highlighter-rouge">OutOfMemory</code> errors), network or transport related issues (such as payload serialization or de-serialization errors), or unexpected code failure (such as <code class="language-plaintext highlighter-rouge">NullPointerException</code> or <code class="language-plaintext highlighter-rouge">ClassCastException</code>).</p><p>There is significant variation in how you handle the different types of exceptions. Some of the exception handling mechanisms are listed below:</p><ul><li><p>Expected business exceptions are typically handled in the code. Handling could involve logging the exception, updating entities and their state, generating exception events, or consuming the exception and moving on.</p><li><p>Exceptions due to invalid payloads (including serialization or de-serialization issues) will not be solved with retries. Such events are referred as <code class="language-plaintext highlighter-rouge">poision pills</code> in Kafka (because it blocks subsequent messages of that partition). Intervention might be required for such events. It is advisable to move them to a dead letter queue (DLQ). The DLQ consumers should allow correction and replay of events.</p><li><p>System exceptions due to unavailability of components are temporary in nature. Hence, multiple retries should be configured. Another key configuration parameter is backoff multiplier. It is used to have exponentially increasing time interval between consecutive retries. Different frameworks have different strategies if the failure persists after retries. For instance, Camel would move the event to a DLQ. Kafka streams would stop the processing. It is advisable to use the default behavior of the frameworks in such scenarios.</p><li><p>Resource issues (such as <code class="language-plaintext highlighter-rouge">OutOfMemory</code> errors) are typically at the component level and would result in the unavailability of a component. The risk of losing events is minimal here due to the fault tolerant nature of the event broker. Also, when deployed in a Kubernetes environment, new pods are started to replace failed pods.</p><li><p>The SAGA pattern is used where data consistency is very important and processing involves multiple microservices. Use the SAGA pattern for those events where data consistency requirements are very strict.</p><li><p>Recovery and replay should be thought about from the beginning and not applied as an afterthought (it becomes extremely complex later). Recovery and replay components are typically custom developed and vary based on event processing. The simplest replay component might just pick up the failed event and republish it on the input topic.</p></ul><p>Your development framework should support having a consistent exception handling strategy across all microservices. It should provide a set of predefined exception classes for business exceptions and provide a generic exception handler that can be customized using configuration but enforces architectural decisions related to exception handling. Most development frameworks do provide such support. However, they need to be configured correctly or extended to provide the required features.</p><p><br /></p><h3 id="event-backbone-capabilities-and-constraints"> <a href="#event-backbone-capabilities-and-constraints" aria-labelledby="event-backbone-capabilities-and-constraints" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Event Backbone Capabilities and Constraints</h3><p>Different event backbone products or platforms provide support for architectural qualities differently. At the same time, they impose constraints on design and architecture. While defining the architecture, their capabilities and constraints should be considered to effectively address the non-functional requirements. For example, the following are few important capabilities and constraints for <a href="https://kafka.apache.org/" target="_blank">Kafka</a>.</p><ul><li>Kafka provides support for event ordering based on partition keys. It also ensures that there is a single consumer (thread) listening on a partition. This makes it very easy to order events just by selecting an appropriate partition key. For example, <code class="language-plaintext highlighter-rouge">OrderId</code>, when used as an partition key, will ensure that all events related to a particular order will be processed in the order of their arrival.<li>Kafka supports <code class="language-plaintext highlighter-rouge">idempotence</code> for producers. This means Kafka ensures that an event is produced exactly once by a producer. Developers don’t need to worry about it.<li>Kafka provides <code class="language-plaintext highlighter-rouge">at least once</code> delivery guarantee. This means consumers should be able to handle duplicate messages. Developers need to be aware of the guarantees provided by their event brokers.<li>Another important aspect for Kafka is an <code class="language-plaintext highlighter-rouge">offset-commit</code> strategy for consumers, which means whether events should be automatically or manually acknowledged. If auto-commit is enabled, events that produce an error might get lost (if exceptions are consumed) or the consumer might see duplicate messages. Manual commits can be used to counter this, but it requires additional code. Frameworks such as spring-cloud-stream that work seamlessly with Kafka, provide the choice of not <code class="language-plaintext highlighter-rouge">auto-committing</code> in case of errors or moving the failed events to a DLQ in addition to manual/auto-commit. This is an important aspect that needs to be thought through during design.<li>Kafka Streams provides the ability to process event streams and easily perform various advanced and complex operations on event streams such as aggregations and joins. This makes it is very easy to perform analytics in real time. For example, computing <em>real-time</em> statistics of events grouped by various dimensions requires very minimal coding. These are stateful operations and maintain a state. Kafka also provides automatic fault-tolerance through <em>state-stores</em>.</ul><p><br /></p><h3 id="security"> <a href="#security" aria-labelledby="security" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Security</h3><p>Developers must consider these aspects of security in EDA-microservices architectures:</p><ul><li>Transport level security<li>Authenticated &amp; authorized access to event production and consumption<li>Audit trails for event processing<li>Data security (such as authorized access and encrypted storage)<li>Eliminating vulnerabilities in the code<li>Perimeter security devices and patterns</ul><p><br /></p><h3 id="observability"> <a href="#observability" aria-labelledby="observability" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Observability</h3><p>Observability includes monitoring, logging, tracing, and alerting. Each component of the system should be observable to avoid failures and also to quickly recover from failures.</p><p>Most of the EDA products and development frameworks provide support for observability by publishing metrics that can be exported into industry-standard observability tools such as Prometheus and Grafana, ELK, StatsD and Graphite, Splunk, or AppDynamics. For example, Apache Kafka provides detailed metrics that can be exported and integrated with most of these tools. Also, cloud platforms that offer managed services for an event backbone (IBM Event Streams) provide first class support for observability. Microservices development frameworks such as Spring or Camel provide good support for code instrumentation for monitoring.</p><p>From an EDA perspective, instrumenting the code of producers and consumers for publishing metrics, publishing event broker metrics, and correlating these through a metrics dashboard is essential because the number of distributed components in EDA is high. Some of the key metrics from an EDA perspective are rate of incoming and outgoing messages, lag in consumption, network latency, queue and topic sizes, and so on.</p><p>For monitoring microservices, refer to my article on <a href="https://developer.ibm.com/tutorials/monitor-spring-boot-microservices/#">Monitor Spring Boot microservices</a> for a detailed tutorial on instrumenting and monitoring microservices.</p><p><br /></p><h3 id="fault-tolerance-and-response"> <a href="#fault-tolerance-and-response" aria-labelledby="fault-tolerance-and-response" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> Fault Tolerance and Response</h3><p>To provide adequate <strong>fault tolerance</strong>, the architecture needs to provide redundancy, exception handling, and elastic scaling (scaling up when thresholds are breached and scaling down when load returns to normal). With EDA and cloud, most of these can be easily achieved. Event backbones cater to fault-tolerance by supporting the clustering and replication of queues and topics. Producers and consumers can have multiple instances deployed. When deployed as containers on a Kubernetes platform, elastic scaling can be easily achieved through auto-scaling (using horizontal pod auto-scalers) but exception handling has to be designed for producers and consumers.</p><p>Although EDA-based systems provide for resiliency through staged architecture, quick <strong>failure response and recovery</strong> is critical to avoid delays and consistency issues. To achieve this quick recovery, you need:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>* Automation for starting and stopping instances and restarting failed instances, which can be easily configured in Kubernetes-based platforms, such as Red Hat OpenShift
* Raising alerts and incidents as and when failures occur
* A well-defined incident management process
* Availability of logs and the ability to correlate logs across multiple components through tracing. Tracing needs to be enabled in microservices. Development frameworks such as spring-sleuth can be used for this. For log aggregation, tools such as ELK or Splunk can be used. This would help the team identify the root cause and resolve the issue quickly.
</code></pre></div></div><p><br /></p><h3 id="references"> <a href="#references" aria-labelledby="references" class="anchor-heading"><svg viewBox="0 0 16 16" aria-hidden="true"><use xlink:href="#svg-link"></use></svg></a> References</h3><ul><li><a href="https://developer.ibm.com/articles/eda-and-microservices-architecture-best-practices/" target="_blank">Architectural considerations for event-driven microservices-based systems</a><li><a href="https://www.ibm.com/cloud/architecture/architectures/eventDrivenArchitecture" target="_blank">IBM Architecture Centre - Event Driven Architecture</a></ul><hr><footer><p><a href="#top" id="back-to-top">Back to top</a></p><div class="d-flex mt-2"></div></footer></div></div><div class="search-overlay"></div></div>
